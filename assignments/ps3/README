PS3: 6 points

The goal of this problem set is to compile Fish abstract syntax down
to RISC-V assembly code.

*******************************
IMPORTANT: you must start by installing additional OCaml libraries
using opam to build the starter code.

Run the following:

  opam install ppx_deriving ppx_sexp_conv sexp

from a terminal.

You should then be able to run "make" in this directory without errors.

Additionally, you probably want to set up the course's Docker images so that
you can assemble the RISCV assembly your solution produeces and simulate your code using qemu.
See the "Resources" tab on the course website for links and instructions.
*******************************

You are to complete the file compile.ml at the places marked with
IMPLEMENT_ME.  There are two big functions to write: one collects up
the set of all variables that occur in a program, and the other
compiles Fish programs down to RISC-V assembly.  The goal is, if the
Fish program being compiled would return an integer n when executed,
then the compiled code should result in a sequence of instructions
such that when finished running, value n is in register x10
(i.e. register a0), and the code finishes by jumping to the address
that was initially in register x1 (the ra register) when execution
began.  You will submit your code by uploading compile.ml to
GradeScope.

You do not need to do any optimization, or have a particularly fast
compiler to get full credit for this assignment.  On the other hand,
if you want to try to do a few transformations, optimizations, or
simplifications, please feel free.  Just make sure to get the basic
code working correctly first.

I've provided boiler plate code for printing out RISC-V code so that
you can dump the results into a file, assemble it, and load it using
qemu.  The starter code for the compiler is set up so that in the
emitted assembly code, the body of the Fish program follows the label
"main".

In order to not include the solutions for the previous problem set in
this starter code, we have set up two ways to run the compiler. One
way runs a parser generated from lex.mll and parse.mly directly on a
.fish source file and then tries to compile it, and the other runs on
a pre-parsed representation called an s-expression that we have
generated by running the reference solution parser on each file.

More specifically, in the tests/ directory, you will see that for each
file with a .fish extension there is another file with a .sexp
extension. Each .sexp file was generated by running a parser on the
corresponding .fish file to generate an AST, converting the AST to
"s-expression" format, and then writing the s-expression to the .sexp
file.  (S-expressions are a convenient way to represent tree like data
structures in a way that is very simple to parse. You don't have to
understand how they work to do this assignment, but if you want to
learn more about working with S-expressions in OCaml check out this
free book chapter:
https://dev.realworldocaml.org/data-serialization.html)

You tell the compiler whether you want to do direct parsing or use sexp
by making the first argument "src" or "sexp" when invoking the compiler.
That is, if you run:

./ps3 src [.fish file to compile]

the code will read the .fish file, try to parse it, run the compiler, and then
print out the compiled RISC-V code.  To use this mode, you must actually copy
over a lex/yacc file for lex.mll and parse.mly.  If you did the lex/yacc
solution to ps2, and got it working, feel free to copy your files over and use
this.

Alternately if you run:

./ps3 sexp [.sexp file to compile]

the code will read the .sexp file, convert it back to an AST, run the
compiler, and then print out the compiled RISC-V.

If you used parser combinators, or didn't get a solution to PS2
working, just use the sexp version to test your files.
In the end, the autograder will test your results against the sexp
version.

When you run one of these commands, you can save the assembly output
to a file.  Recall that it is the job of an assembler to actually
convert assembly into the machine code that can be run. We are going
to use the riscv32 assembler that is included in the GNU gcc /
binutils.  Installing the riscv32 version of gcc and bintuils takes a
bit of work (and time), so I have already set these up inside of the
course docker image, and have provided a script called "docker-gcc.sh"
for running it.

For example, the following commands save the output of compiling in a
file called "tmp.s" and then gcc via docker on that file:

./ps3 sexp test/01cexpr_01add.sexp > tmp.s
sh ./docker-gcc.sh tmp.s

This will product an output binary called "a.out".  Note that gcc
guesses that we're asking it to assemble (rather than compile from C)
based on the ".s" extension of the file.

Now of course, you are probably not using a 32-bit RISC-V CPU in your
computer, so we need a RISC-V emulator to actually execute the binary
we have produced (sort of like the one you produced in PS1, but much
more full featured).

The course infrastructure supports two different emulators, either suffices.
Some students have had trouble getting the qemu emulator to work on Mac.
In that case jump to the section below to continue following the instructions:

## --------- QEMU --------------------

To run the docker version of qemu on the a.out binary we just compiled, we can do:

$ sh ./docker-qemu.sh a.out

When you run that, it should pause and then finish, without displaying
anything. In some sense, that's not surprising -- our Fish program
just computes a value and returns it!

How can we see what what was returned?  qemu actually takes the value
returned by the emulated program and then returns it. In the shell,
the return value of executing a command is stored into the $?
variable, so we can print this to see what a.out returned:

$ sh ./docker-qemu.sh a.out
$ echo $?
16

where the "16" at the end is the value returned by the example program

If qemu ran correctly, jump to the end to read some concluding
remarks, otherwise try using temu following the instructions in the
next section:

## --------- TEMU --------------------

To run the docker version of temu on the a.out binary we just compiled, we can do:

$ sh ./docker-temu.sh a.out

When you run that, it should pause and then finish, and print out the
return value of the Fish program, which should hopefully be "16".


## -------- Warnings and additional notes --------------

Most shells restrict return codes to be in the range [0,255]
(i.e. they will only take the LSB byte of the return value), so if the
fish program returns a value outside this range, when we echo $? on
the shell you won't see the full value. All of the assignment test
cases are careful to lie in the range [0,255]. In later assignments,
once we have function calls working, we'll actually be able to
print output from our programs to test them rather than just
looking at the return value.

WARNING: Your assembly code should NOT modify any caller-saved
registers (or if you do modify them, you need to correctly restore
them before returning) or else the starter code will not work
correctly.
